// Generated by CoffeeScript 1.7.1
var EventEmitter, exec, local, remote, stream;

EventEmitter = require('events').EventEmitter;

stream = require('stream');

exec = require('child_process').exec;

module.exports = function() {
  var callback, options;
  if (arguments.length === 1) {
    options = arguments[0];
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      options = arguments[0];
      callback = arguments[1];
    } else {
      options = {};
      options.ssh = arguments[0];
      options.cmd = arguments[1];
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      callback = arguments[2];
      options = {};
    } else {
      options = arguments[2];
    }
    options.ssh = arguments[0];
    options.cmd = arguments[1];
  } else if (arguments.length === 4) {
    options = arguments[2];
    options.ssh = arguments[0];
    options.cmd = arguments[1];
    callback = arguments[3];
  } else {
    throw new Error('Invalid arguments');
  }
  if (options.ssh) {
    return remote(options, callback);
  } else {
    return local(options, callback);
  }
};

remote = module.exports.remote = function(options, callback) {
  var child, cmdOptions, stderr, stdout;
  child = new EventEmitter;
  child.stdout = new stream.Readable;
  child.stdout._read = function(_size) {};
  child.stderr = new stream.Readable;
  child.stderr._read = function() {};
  child.kill = function(signal) {
    if (signal == null) {
      signal = 'KILL';
    }
    console.log('kill');
    child.stream.write('\x03');
    return child.stream.end('\x03');
  };
  if (options.ssh._host != null) {
    stdout = stderr = '';
    if (options.cwd) {
      options.cmd = "cd " + options.cwd + "; " + options.cmd;
    }
    cmdOptions = {};
    if (options.env) {
      cmdOptions.env = options.env;
    }
    if (options.pty) {
      cmdOptions.pty = options.pty;
    }
    options.ssh.exec(options.cmd, cmdOptions, function(err, stream) {
      var code, endCalled, exit, exitCalled, signal;
      if (err && callback) {
        return callback(err);
      }
      child.stream = stream;
      stream.stderr.on('data', function(data) {
        child.stderr.push(data);
        if (callback) {
          return stderr += data;
        }
      });
      stream.on('data', function(data) {
        child.stdout.push(data);
        if (callback) {
          return stdout += data;
        }
      });
      code = signal = null;
      exitCalled = endCalled = false;
      exit = function() {
        if (!(exitCalled && endCalled)) {
          return;
        }
        child.stdout.push(null);
        child.stderr.push(null);
        child.emit('exit', code, signal);
        if (options.end) {
          connection.end();
          connection.on('error', function() {
            return callback(err);
          });
          return connection.on('close', function() {
            if (callback) {
              return callback(err, stdout, stderr);
            }
          });
        } else {
          if (callback) {
            return callback(err, stdout, stderr);
          }
        }
      };
      stream.on('exit', function() {
        exitCalled = true;
        code = arguments[0], signal = arguments[1];
        return exit();
      });
      return stream.on('end', function() {
        endCalled = true;
        if (code !== 0) {
          if (stderr.trim().length) {
            err = stderr.trim().split('\n');
            err = err[err.length - 1];
          } else {
            err = 'Child process exited abnormally';
          }
          err = new Error(err);
          err.code = code;
          err.signal = signal;
        }
        return exit();
      });
    });
  }
  return child;
};

local = module.exports.local = function(options, callback) {
  var child, cmdOptions, stderr, stdout;
  cmdOptions = {};
  cmdOptions.env = options.env || process.env;
  cmdOptions.cwd = options.cwd || null;
  if (options.uid) {
    cmdOptions.uid = options.uid;
  }
  if (options.gid) {
    cmdOptions.gid = options.gid;
  }
  stdout = new stream.Readable;
  stderr = new stream.Readable;
  child = exec(options.cmd, cmdOptions, callback);
  child.stdout = stdout.wrap(child.stdout);
  child.stderr = stderr.wrap(child.stderr);
  return child;
};
